\chapter{Metodologia}
O software desenvolvido tem como objetivo demonstrar o problema, definindo caminho viáveis entres diferentes endereços, onde é possível realizar as entregas no período limitado, caminhos são impossíveis de ser entregues a tempo e caminhos que serão necessários mais de um entregador para ser realizado. Alertas de não possibilidade de realizar a entrega será comunicadona interface do usuário.

Utilizando a API do Google Maps como fonte de dados, informações reais de distância, tempo médio e localizações são utilizadas para uma simulação mais próxima de uma situação real.
Por se tratar de entregas de pequenos porte, os testes foram criados com endereços dentro ou nas proximidades da cidade de São Paulo, um das maiores metrópoles do mundo, também tem um dos maiores índices de transito também segundo o TomTom Traffic Index \cite{TomTom}, a menor distância de rota pode não ser a melhor escolha para certos horários do dia, as vezes escolher uma rota com maior distância que evita transito primeiro é a melhor escolha para economizar tempo.

Para preparar o calculo da rota, deve-se levar em consideração que todos os entregadores partem de uma única origem que chamamos de deposito,mas antes de começar a calcular as entregas, é calculada uma rota geral que passa por todos os endereços com apenas um entregador, essa rota é divida sempre que o horário de chega a um endereço, ultrapassar o horário limite para realizar todas as entregas. Quando uma rota é divida, primeiro entregador fica com a parte até o endereço que é possível realizar a entrega e é calculada uma nova rota geral com os endereços que sobraram, sendo passado para um novo entregador e partindo do deposito. Todas as vezes que não for possível entregador esse processo será repetido até que seja possível.

Existem situações onde não é possível entregar, mesmo com um numero alto de entregadores, essas situação podem depender da distancia, se for muito longe não tem como chegar no horário, do horário de abertura e fechamento, se forem muito próximos qualquer mudança no transito torna impossível realizar a entrega, também a situação do numero limitado de entregadores, que não pode ser um número infinito, muitos endereços para poucos entregadores pode ser impossível de se realizar a entrega.

Cada endereço tem um horário de abertura e fechamento para realizar entregas, por exemplo, um super mercado recebe nos produtos na madrugada, por que receber em seu horário normal de abertura irá atrapalhar as compras dos clientes, então esse horário deve ser considerado para a escolha do próximo endereço. 
Depois que chega ao endereço se verifica o horário de abertura, se chegar antes, deve-se esperar até abrir, se chegar no horário ou depois do horário, antes do fechamento, o tempo de descarga que é considerado.
Cada entrega também tem um tempo médio que demora para realizar a descarga do produto, produtos pequenos podem demorar minutos, muitos produtos demora mais para retirar do veiculo e produtos grande podem precisar ser levamos com mais demora.

Depois que uma entrega é feita, uma nova rota deve ser recalculada, agora como ponto inicial o endereço atual, todo o processo será refeito para verificar se o transito ou possível atrasos não afetaram a ordem dos próximos destinos, depois do recalculo o entregador deve seria o próximo destino indicado.

Se caso não for mais possível entregar no horário por motivos de piora de transito ou um grande tempo de atraso para descarregar, um alerta será emitido indicando que todos os destinos não podem ser visitados a tempo.
Cada entregador tem seu próprio recalculo de rota, sendo que se um entregador concluir todos os destinos, os outros continuam pedindo novas rotas até que todos terminem suas entregas.

O fluxograma a baixo demostra o funcionamento do software.

\begin{minipage}{\linewidth}
    \makebox[\linewidth]{
        \includegraphics[keepaspectratio=true,scale=0.5]{ibagens/Fluxograma.png}}
    \captionof{figure}{Fluxograma macro do funcionamento do software.  }
    \label{fig:FluxoSoftware}
\end{minipage}

O GA considera como um individuo um percurso inteiro, ponto do estoque, e todos os destinos.Uma rota aleatória é calculada para cada individuo como população inicial.

A mutação e o cruzamento alterna os pontos de destino, mantendo o estoque sempre fixo.
A função de aptidão do GA considera o horário de saída como parâmetros inicial, com isso, utiliza o tempo dado pelo Google Maps entra os pontos e soma ao horário verificando se está dentro da janela de tempo do destino. Se o horário calculo for menor que o de abertura, é somado o tempo restante de espera. Se o horário for maior que o tempo de fechamento, é somado o tempo restante de espera até a abertura no próximo dia. Sempre que não chegar em um horário entra a janela de tempo, a penalidade é o tempo de espera, fazendo o tempo total ganhe mais peso no valor de aptidão. O Valor de aptidão final é a soma da distancia em metros do percurso passando por todos os pontos, com o tempo total em minutos.

O GA foi configurado com o Numero de Gerações em 200, tamanho da População em 1000, melhores indivíduos por geração em 20, probabilidade de cruzamento em 50\% e probabilidade de Mutação em 0,1\%.

Os Testes foram configurados com um numero de 5 roteiros diferentes, endereços dentro da cidade de São Paulo e cidades próximas. Utilizando 6 tipos de mutação, sendo SM, IVM, IM, EM, DM e DIVM, e 3 tipos de cruzamento, sendo Simples, PBX e OBX.
Considerando o transito médio enviado pelo Google Maps, para poder demostrar o impacto do transito nos caminhos calculados.

Tudo será rodado 10 vezes e será retirada uma média do valor de aptidão, por que, cada vez que roda o GA a resposta da solução pode mudar, por ele não ser determinístico.

E uma base pré-definidas rotas, para prevenir possíveis problemas sera ignorado o transito atual. Ja que o mesmo altera dependendo das condições do clima ou horário do dia. Então utilizando o Google Maps, um cache inicial foi preparado e o software utiliza simulando uma buscar ao Google Maps, com isso, a informação é obtida mais rapidamente e sempre fixa para garantir a resposta pré-determinada do teste.
Os parâmetros utilizados são

O fluxograma a baixo demostra o funcionamento do software utilizando o GA.

\begin{minipage}{\linewidth}
	\makebox[\linewidth]{
		\includegraphics[keepaspectratio=true,scale=0.5]{ibagens/GA.png}}
	\captionof{figure}{Fluxograma macro da integração com o GA.}
	\label{fig:FluxoGA}
\end{minipage}

\chapter{Implementação}
 
Nesse capitulo será apresentado mais aprofundadamente as ferramentas e métodos que foram utilizados para a implementação do algoritmo genético para busca de rota com janela de tempo.
 
\section{O Projeto}
O software é separado em três projetos, todos utilizando .Net Core 2.0 com a linguagem C\# no Visual Studio 2017 para plataforma Windows ou \**nix.

O \textbf{PathFinder.Routes} nesse projeto estão os algoritmos de comunicação com o Google Maps e organização de rotas.

O \textbf{PathFinder.GeneticAlgorithm} nesse projeto estão as implementações para a utilização do algoritmo genético.

O \textbf{PathFinder} projeto principal para inicialização do software e utiliza os dois outros projetos em sua implementação.

\section{Organização}
Os projetos são organizados utilizando o padrão do Visual Studio chamado de Solution.

\subsection{PathFinder}
Projeto de inicialização no modo console, todo progresso do software é exibido em texto.

\textbf{Program:} Implementação das união de todas as classes, executa a separação dos entregadores.

\textbf{Entregador:} Informação individual, armazena a rota completa do entregar e o genoma representante.

\textbf{TimeMeasure:} Configuração de registro/exibição do tempo de processamento.
\subsection{PathFinder.Routes}

Projeto de integração com o Google Mapas e classes de apoio do software.

\textbf{GoogleMaps:} Classes de estrutura para serialização do Json de retorno da API do Google Maps.

\textbf{MapPoint:} Classe com informações do ponto de destino com latitude, longitude e janela de tempo para a entrega.

\textbf{Period:} Classe para a definição da janela de tempo.

\textbf{Route:} Classe para definição da origem e destino de uma rota, contendo o tempo e a distância entra os pontos.

\textbf{RouteMap:} Classe para a definição da rota completo e o armazém. A definição de cada caminho completo é controlado nessa classe. 

\textbf{SearchRoute:} Classe para a integração com a API do Google maps.

\subsection{PathFinder.GeneticAlgorithm}
Neste projeto são definidos todas as implementações referentes ao algoritmo genético, pela complexidade do algoritmo ele possui uma estrutura própria de pastas para definições e configurações de injeção de dependência.

\subsection{Abstraction}

Nesta pasta estão todos os arquivos a nível de abstração das etapas do algoritmo genético.

\textbf{ISelection}: Interface é responsável por abstrair os algoritmos de seleção.

\textbf{IGenome}: Interface tem como funcionalidade abstrair a definição de genoma.

\textbf{IFitness}: Interface tem como objetivo abstrair o calculo de fitness.

\textbf{IMutate}: Interface tem como objetivo abstrair os operadores de mutação.

\textbf{ICrossover}:  Interface tem como objetivo abstrair os operadores de cruzamento.

\textbf{IRandom}: Interface tem como objetivo abstrair a implementação de geração de números aleatórios.

\textbf{AbstractMutate}: Implementação base para operador de mutação.

\textbf{AbstractCrossover}: Implementação base para operador de cruzamento.

\subsection{Core}

\textbf{Enumerators}: Contem as definições de enumerações, usados para usar nomes bem definidos ao invés de números avulsos no código.

\textbf{RandomAdapter}: Implementação responsável por gerar números aleatórios, implementa IRandom.

\textbf{GASettings}: Arquivo responsável por carregar configuração estática de GA.

\textbf{Genome}: Classe responsável por representar o genoma no algoritmo de GA, implementa a IGenome.

\subsection{Selection}

Nesta pasta estão todas as implementações dos algoritmos de seleção.

\textbf{SelectionRouletteWheel}: Implementação de seleção roleta.

\subsection{Crossover}

Nesta pasta estão todas as implementações dos algoritmos de cruzamento.

\textbf{CrossoverOBX}: Implementação do operador de cruzamento OBX.

\textbf{CrossoverPBX}: Implementação do operador de cruzamento PBX.

\textbf{CrossoverSimple}:  Implementação do operador de cruzamento simples.

\subsection{Mutation}

Nesta pasta estão todas as implementações dos algoritmos de mutação.

\textbf{MutateBitwise}: Implementação do operador de cruzamento Bitwise.

\textbf{MutateDIVM}: Implementação do operador de cruzamento DIVM.

\textbf{MutateDM}: Implementação do operador de cruzamento DM.

\textbf{MutateEM}: Implementação do operador de cruzamento EM.

\textbf{MutateIM}: Implementação do operador de cruzamento IM.

\textbf{MutateIVM}: Implementação do operador de cruzamento IVM.

\textbf{MutateSM}: Implementação do operador de cruzamento SM.

\subsection{Fitness}

Nesta pasta estão todas as implementações dos algoritmos de fitness.

\textbf{FitnessTimePath}: Implementação do fitness que considera o menor caminho e o tempo, para chegar no destino dentro da janela de tempo como a melhor solução.

\section{Funcionalidades}
O software é composto por funcionalidade individuais que podem ser utilizadas separadamente se necessário e também entender cada uma, ajuda a entender o software por completo.

\textbf{Integração com a API do Google Maps:} Usando a classe SearchRoute do projeto PathFinder.Routes é possível procurar rotas e endereços do Google Maps e obter informação de coordenadas geográficas de um ponto usando o endereço, calcular rota entre dos dois usando o endereço ou com as coordenadas geográficas, obter um mapa estático de um ou vários pontos.


\textbf{Algoritmos Genéticos} O modulo de GA poderia ser utilizado separadamente, porém é preciso o desenvolvimento da função de aptidão para o caso que ele será utilizado, o resto da estrutura funcionaria.