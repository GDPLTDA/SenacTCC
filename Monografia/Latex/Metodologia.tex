\chapter{Metodologia}
O software tem que demostrar que serve para a situação proposta, com isso, diferentes rotas em situações onde é possível encontrar o caminho, ou não, foram criadas de forma a testar o software e evitar possíveis erros ou falsos positivos.
Utilizando a API do Google Maps como fonte de dados, informações reais de distância, tempo médio e localização são utilizadas para uma simulação mais próxima de uma situação real.

Por se tratar de entregas de pequenos porte, os testes foram criados com coordenadas a nível de cidade, São Paulo é a cidade para os testes, por se tratar de uma cidade com um alto índice de transito segundo o TomTom Traffic Index \cite{TomTom}, a menor rota pode não será a melhor escolha para aquele horário do dia.

Todos os entregadores saem de uma única origem, antes de começar a entrega, é calculada uma rota geral, e ela é dividida de forma a entregar rotas possível para cada entregar, se o limite de entregados for ultrapassado, um avisa será emitido recomendando que deixe para o próximo dia as entregas mais distantes.

Cada destino tem um período permitido para entrega, e cada entrega demora no máximo 5 minutos para ser descarregada. Depois que uma entrega é feita, o software recalcula o próximo destino com base no transito atual e o período para entregar.
Se caso não é mais possível entregar no horário por causa do transito piorou, um alerta será emitido. Depois que o entregador terminou todas suas entregas, o software continua auxiliando os outros entregadores, até concluir todas as entregas.

O fluxograma a baixo demostra o funcionamento do software.

\begin{minipage}{\linewidth}
	\makebox[\linewidth]{
		\includegraphics[keepaspectratio=true,scale=0.5]{ibagens/Fluxograma.png}}
	\captionof{figure}{Fluxograma macro do funcionamento do software.  }
	\label{fig:FluxoSoftare}
\end{minipage}

Nos testes foram definidas rotas pré-definidas para possíveis problemas, ignorando o transito atual. por que o transito altera dependendo das condições do clima ou horário do dia. Então utilizando o Google Maps, um cache inicial foi preparado e o software utiliza simulando uma buscar ao Google Maps, com isso, a informação é obtida mais rapidamente e sempre fixa para garantir a resposta pre-determinada do teste.

\chapter{Implementação}
 
Nesse capitulo será apresentado mais aprofundadamente as ferramentas e métodos que foram utilizados para a implementação do algoritmo genético para busca de rota com janela de tempo.
 
\section{O Projeto}
O software é separado em três projetos, todos utilizando .Net Core 2.0 com a linguagem C\# no Visual Studio 2017 para plataforma Windows ou \**nix.

O \textbf{PathFinder.Routes} nesse projeto estão os algoritmos de comunicação com o Google Maps e organização de rotas.

O \textbf{PathFinder.GeneticAlgorithm} nesse projeto estão as implementações para a utilização do algoritmo genético.

O \textbf{PathFinder} projeto principal para inicialização do software e utiliza os dois outros projetos em sua implementação.

\section{Organização}
Os projetos são organizados utilizando o padrão do visual studio chamado de Solution.

\subsection{PathFinder}
Projeto de inicialização no modo console, todo progresso do software é exibido em texto.

\textbf{Program:} Implementação das união de todas as classes, executa a separação dos entregadores.

\textbf{Entregador:} Informação individual, armazena a rota completa do entregar e o genoma representante.

\textbf{TimeMeasure:} Configuração de registro/exibição do tempo de processamento.
\subsection{PathFinder.Routes}

Projeto de integração com o Google Mapas e classes de apoio do software.

\textbf{GoogleMaps:} Classes de estrutura para serialização do Json de retorno da API do Google Maps.

\textbf{MapPoint:} Classe com informações do ponto de destino com latitude, longitude e janela de tempo para a entrega.

\textbf{Period:} Classe para a definição da janela de tempo.

\textbf{Route:} Classe para definição da origem e destino de uma rota, contendo o tempo e a distância entra os pontos.

\textbf{RouteMap:} Classe para a definição da rota completo e o armazém. A definição de cada caminho completo é controlado nessa classe. 

\textbf{SearchRoute:} Classe para a integração com a API do Google maps.

\subsection{PathFinder.GeneticAlgorithm}
Neste projeto são definidos todas as implementações referentes ao algoritmo genético, pela complexidade do algoritmo ele possui uma estrutura própria de pastas para definições e configurações de injeção de dependência.

\subsection{Abstraction}

Nesta pasta estão todos os arquivos a nível de abstração das etapas do algoritmo genético.

\textbf{ISelection}: Interface é responsável por abstrair os algoritmos de seleção.

\textbf{IGenome}: Interface tem como funcionalidade abstrair a definição de genoma.

\textbf{IFitness}: Interface tem como objetivo abstrair o calculo de fitness.

\textbf{IMutate}: Interface tem como objetivo abstrair os operadores de mutação.

\textbf{ICrossover}:  Interface tem como objetivo abstrair os operadores de cruzamento.

\textbf{IRandom}: Interface tem como objetivo abstrair a implementação de geração de números aleatórios.

\textbf{AbstractMutate}: Implementação base para operador de mutação.

\textbf{AbstractCrossover}: Implementação base para operador de cruzamento.

\subsection{Core}

\textbf{Enumerators}: Contem as definições de enumerações, usados para usar nomes bem definidos ao invés de números avulsos no código.

\textbf{RandomAdapter}: Implementação responsável por gerar números aleatórios, implementa IRandom.

\textbf{GASettings}: Arquivo responsável por carregar configuração estática de GA.

\textbf{Genome}: Classe responsável por representar o genoma no algoritmo de GA, implementa a IGenome.

\subsection{Selection}

Nesta pasta estão todas as implementações dos algoritmos de seleção.

\textbf{SelectionRandom}: Implementação de seleção de indivíduos aleatório.
\textbf{SelectionRouletteWheel}: Implementação de seleção roleta.

\subsection{Crossover}

Nesta pasta estão todas as implementações dos algoritmos de cruzamento.

\textbf{CrossoverOBX}: Implementação do operador de cruzamento OBX.

\textbf{CrossoverPBX}: Implementação do operador de cruzamento PBX.

\textbf{CrossoverSimple}:  Implementação do operador de cruzamento simples.

\subsection{Mutation}

Nesta pasta estão todas as implementações dos algoritmos de mutação.

\textbf{MutateBitwise}: Implementação do operador de cruzamento Bitwise.

\textbf{MutateDIVM}: Implementação do operador de cruzamento DIVM.

\textbf{MutateDM}: Implementação do operador de cruzamento DM.

\textbf{MutateEM}: Implementação do operador de cruzamento EM.

\textbf{MutateIM}: Implementação do operador de cruzamento IM.

\textbf{MutateIVM}: Implementação do operador de cruzamento IVM.

\textbf{MutateSM}: Implementação do operador de cruzamento SM.

\subsection{Fitness}

Nesta pasta estão todas as implementações dos algoritmos de fitness.

\textbf{FitnessSmallPath}: Implementação do fitness que considera o menor caminho como a melhor solução.

\textbf{FitnessTimePath}: Implementação do fitness que considera o menor caminho e o tempo, para chegar no destino dentro da janela de tempo como a melhor solução.

\section{Funcionalidades}
O software é composto por funcionalidade individuais que podem ser utilizadas separadamente se necessário e também entender cada uma, ajuda a entender o software por completo.

\textbf{Integração com a API do Google Maps:} Usando a classe SearchRoute do projeto PathFinder.Routes é possível procurar rotas e endereços do Google Maps e obter informação de coordenadas geográficas de um ponto usando o endereço, calcular rota entre dos dois usando o endereço ou com as coordenadas geográficas, obter um mapa estático de um ou vários pontos.






